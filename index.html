<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Art Techo Designer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* ====================================
           BASE STYLES
           ==================================== */
        body { 
            transition: background-color 0.3s ease;
        }
        
        /* ====================================
           CANVAS STYLES
           ==================================== */
        #drawingCanvas {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            touch-action: none; /* Prevent default touch behaviors for better drawing */
            display: block; 
            cursor: crosshair;
            background-color: white;
        }
        
        /* ====================================
           SCROLLBAR CUSTOMIZATION
           ==================================== */
        .custom-scroll::-webkit-scrollbar { 
            width: 6px; 
        }
        .custom-scroll::-webkit-scrollbar-thumb { 
            background-color: #6b7280; 
            border-radius: 3px; 
        }
        .custom-scroll::-webkit-scrollbar-track { 
            background-color: #f3f4f6; 
        }

        /* ====================================
           ACTIVE TOOL HIGHLIGHTING
           ==================================== */
        .tool-active {
            background-color: #3b82f6 !important; /* Blue-500 */
            color: white !important;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }

        /* ====================================
           CANVAS RESIZE HANDLE
           ==================================== */
        #resize-handle {
            position: absolute; 
            bottom: -8px; 
            right: -8px; 
            width: 16px; 
            height: 16px;
            background-color: #3b82f6; 
            border: 2px solid white; 
            border-radius: 4px;
            cursor: nwse-resize; 
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
        }

        /* ====================================
           LINE LENGTH POPUP
           ==================================== */
        #line-length-popup {
            transform: translate(-50%, -120%); 
            white-space: nowrap;
            transition: opacity 0.1s ease-in-out;
        }
        
        /* ====================================
           COLOR PICKER WRAPPER
           ==================================== */
        .color-input-wrapper {
            width: 40px; 
            height: 40px; 
            flex-shrink: 0;
            padding: 2px;
            box-sizing: content-box;
        }
        
        /* ====================================
           BACKGROUND TRANSPARENCY INDICATORS
           ==================================== */
        
        /* Overlay for hex input area */
        #bg-indicator {
            position: absolute; 
            inset: 0; 
            background-color: white;
            z-index: 10;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            pointer-events: none; 
            transition: opacity 0.3s ease;
            opacity: 0; /* Hidden by default */
            right: 40px; /* Make room for the eye icon button */
        }
        
        /* Overlay for color picker box */
        #bg-indicator-color-picker {
            position: absolute; 
            inset: 0; 
            background-color: white;
            z-index: 10;
            border: 1px solid #d1d5db; 
            border-radius: 6px; 
            pointer-events: none; 
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease;
        }
        
        /* Show indicators when transparent mode is active */
        #bg-indicator.transparent, 
        #bg-indicator-color-picker.transparent {
            opacity: 1;
        }
        
        /* Red diagonal line for color picker indicator */
        #bg-indicator-color-picker.transparent::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #ef4444; /* red-500 */
            transform: translateY(-50%) rotate(-45deg);
        }

        /* Hide native color picker when in transparent mode */
        .color-input-wrapper input[type="color"] {
            opacity: 1;
            pointer-events: auto;
            transition: opacity 0.3s ease;
        }
        .color-input-wrapper.transparent-bg-wrapper input[type="color"] {
            opacity: 0;
            pointer-events: none;
        }
        
        /* "TRANSPARENT" text label styling */
        #bg-indicator-label {
            color: #4b5563; /* gray-600 for light mode */
        }

        /* ====================================
           DARK MODE OVERRIDES
           ==================================== */
        body[data-theme='dark'] { 
            background-color: #1f2937; 
        }
        body[data-theme='dark'] .bg-white { 
            background-color: #374151; 
        }
        body[data-theme='dark'] .text-gray-800, 
        body[data-theme='dark'] .text-gray-700,
        body[data-theme='dark'] .text-gray-900 { 
            color: #f3f4f6; 
        }
        body[data-theme='dark'] .border-b, 
        body[data-theme='dark'] .border-t,
        body[data-theme='dark'] .border-gray-300 { 
            border-color: #4b5563; 
        }
        body[data-theme='dark'] .tool-btn:not(.tool-active) { 
            background-color: #374151; 
            color: #f3f4f6; 
        }
        body[data-theme='dark'] .hover\:bg-gray-100:hover:not(.tool-active):not(.bg-gray-200) { 
            background-color: #4b5563; 
        }
        body[data-theme='dark'] .bg-gray-200 { 
            background-color: #4b5563; 
            color: #f3f4f6; 
        }
        body[data-theme='dark'] .hover\:bg-gray-300:hover { 
            background-color: #6b7280; 
        }
        body[data-theme='dark'] input[type="text"] { 
            background-color: #4b5563; 
            border-color: #6b7280; 
            color: #f3f4f6; 
        }
        body[data-theme='dark'] #drawingCanvas { 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8); 
        }
        body[data-theme='dark'] .slider-track { 
            background-color: #4b5563; 
        }
        body[data-theme='dark'] #bg-indicator { 
            background-color: #4b5563; 
            border-color: #6b7280;
        }
        body[data-theme='dark'] #bg-indicator-color-picker { 
            background-color: #4b5563; 
            border-color: #6b7280; 
        }
        body[data-theme='dark'] #toggle-transparent {
            color: #d1d5db; /* gray-300 for contrast */
        }
        body[data-theme='dark'] #bg-indicator-label {
            color: #f3f4f6; /* Light text for dark mode */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex items-start justify-center font-sans" data-theme="light">

    <div id="app" class="flex flex-col md:flex-row gap-6 max-w-7xl w-full">

        <!-- ====================================
             LEFT PANEL: TOOLBAR & CONTROLS
             ==================================== -->
        <div class="bg-white p-6 rounded-xl shadow-lg w-full md:w-80 flex-shrink-0 custom-scroll overflow-y-auto max-h-[90vh] transition-colors">
            
            <!-- App Header with Theme Toggle -->
            <div class="flex justify-between items-center mb-6 border-b pb-2">
                <h1 class="text-2xl font-bold text-gray-800 transition-colors">Art Techo Designer</h1>
                <button id="theme-toggle" class="p-2 rounded-full bg-gray-200 hover:bg-gray-300 transition-colors duration-150" aria-label="Toggle dark mode">
                    <!-- Sun icon for light mode -->
                    <svg id="sun-icon" class="w-6 h-6 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
                    </svg>
                    <!-- Moon icon for dark mode -->
                    <svg id="moon-icon" class="w-6 h-6 text-gray-200 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
                    </svg>
                </button>
            </div>

            <!-- Drawing Tools -->
            <div class="mb-6">
                <h2 class="text-lg font-semibold mb-3 text-gray-700 transition-colors">Tools</h2>
                <div class="grid grid-cols-3 gap-3">
                    <!-- Line Tool -->
                    <button id="tool-line" data-tool="line" class="tool-btn p-3 rounded-lg border border-gray-300 hover:bg-gray-100 transition duration-150 tool-active" aria-label="Line tool">
                        <svg class="w-6 h-6 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path>
                        </svg>
                        <span class="text-xs mt-1 block">Line</span>
                    </button>
                    <!-- Circle Tool -->
                    <button id="tool-circle" data-tool="circle" class="tool-btn p-3 rounded-lg border border-gray-300 hover:bg-gray-100 transition duration-150" aria-label="Circle tool">
                        <svg class="w-6 h-6 mx-auto" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="12" cy="12" r="9" stroke-width="2" fill="none"/>
                            <circle cx="12" cy="12" r="2" fill="currentColor" stroke="none"/>
                        </svg>
                        <span class="text-xs mt-1 block">Circle</span>
                    </button>
                    <!-- Eraser Tool -->
                    <button id="tool-eraser" data-tool="eraser" class="tool-btn p-3 rounded-lg border border-gray-300 hover:bg-gray-100 transition duration-150" aria-label="Eraser tool">
                        <svg class="w-6 h-6 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                        <span class="text-xs mt-1 block">Eraser</span>
                    </button>
                </div>
            </div>

            <!-- Color Controls -->
            <div class="mb-6 border-t pt-4">
                <h2 class="text-lg font-semibold mb-3 text-gray-700 transition-colors">Colors</h2>

                <!-- Background Color with Transparency Toggle -->
                <label class="block text-sm font-medium text-gray-700 mb-1 transition-colors">Background</label>
                <div class="flex items-center space-x-2 mb-4">
                    <!-- Color Picker -->
                    <div class="relative color-input-wrapper" id="bgColorWrapper">
                        <div id="bg-indicator-color-picker"></div> 
                        <input type="color" id="bgColor" value="#ffffff" class="w-full h-full p-0 rounded-md border-2 border-gray-300 cursor-pointer transition-colors" aria-label="Background color picker">
                    </div>

                    <!-- Hex Input with Transparency Toggle -->
                    <div id="bgColorHexWrapper" class="relative flex-grow">
                        <div id="bg-indicator">
                            <span id="bg-indicator-label" class="absolute inset-0 flex items-center justify-center font-bold text-sm">TRANSPARENT</span>
                        </div> 
                        <input type="text" id="bgColorHex" value="#ffffff" maxlength="7" placeholder="#ffffff" class="w-full p-2 pr-10 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 transition-colors text-sm font-mono" aria-label="Background color hex value">
                        <!-- Eye/Eye-Off Toggle Button -->
                        <button id="toggle-transparent" class="absolute inset-y-0 right-0 flex items-center justify-center p-2 rounded-r-md hover:bg-gray-100 transition-colors text-gray-600 w-10" style="z-index: 20;" title="Toggle Transparency" aria-label="Toggle transparency">
                             <!-- SVG icon injected via JavaScript -->
                        </button>
                    </div>
                </div>

                <!-- Line/Circle Color -->
                <label for="drawColor" class="block text-sm font-medium text-gray-700 mb-1 transition-colors">Line/Circle</label>
                <div class="flex items-center space-x-2 mb-4">
                    <div class="relative color-input-wrapper">
                        <input type="color" id="drawColor" value="#000000" class="w-full h-full p-0 rounded-md border-2 border-gray-300 cursor-pointer transition-colors" aria-label="Line and circle color picker">
                    </div>
                    <input type="text" id="drawColorHex" value="#000000" maxlength="7" placeholder="#000000" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 transition-colors text-sm font-mono" aria-label="Line and circle color hex value">
                </div>
                
                <!-- Glow Color -->
                <label for="glowColor" class="block text-sm font-medium text-gray-700 mb-1 transition-colors">Glow Color</label>
                <div class="flex items-center space-x-2 mb-4">
                    <div class="relative color-input-wrapper">
                        <input type="color" id="glowColor" value="#77ffff" class="w-full h-full p-0 rounded-md border-2 border-gray-300 cursor-pointer transition-colors" aria-label="Glow color picker">
                    </div>
                    <input type="text" id="glowColorHex" value="#77ffff" maxlength="7" placeholder="#77ffff" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 transition-colors text-sm font-mono" aria-label="Glow color hex value">
                </div>

                <!-- Glow Distance Slider -->
                <label for="glowDistance" class="block text-sm font-medium text-gray-700 mb-1 transition-colors">Glow Distance</label>
                <div class="flex items-center space-x-3 mb-1">
                    <input type="range" id="glowDistance" min="0" max="3" value="0" step="1" class="w-full h-2 bg-gray-200 slider-track rounded-lg appearance-none cursor-pointer" aria-label="Glow distance slider">
                </div>
                <!-- Evenly spaced labels for slider -->
                <div class="relative text-xs text-gray-500 mt-1 h-4">
                    <span class="absolute left-0">0px</span>
                    <span class="absolute left-1/3 -translate-x-1/2">1px</span>
                    <span class="absolute left-2/3 -translate-x-1/2">2px</span>
                    <span class="absolute right-0">3px</span>
                </div>
            </div>

            <!-- Line Thickness Controls -->
            <div class="mb-6 border-t pt-4">
                <h2 class="text-lg font-semibold mb-3 text-gray-700 transition-colors">Line Thickness</h2>
                <div class="flex space-x-2 justify-center">
                    <button data-thickness="2" class="thickness-btn w-1/3 p-3 border rounded-lg hover:bg-gray-100 transition duration-150" aria-label="2 pixel thickness">2px</button>
                    <button data-thickness="4" class="thickness-btn w-1/3 p-3 border rounded-lg hover:bg-gray-100 transition duration-150 tool-active" aria-label="4 pixel thickness">4px</button>
                    <button data-thickness="6" class="thickness-btn w-1/3 p-3 border rounded-lg hover:bg-gray-100 transition duration-150" aria-label="6 pixel thickness">6px</button>
                </div>
            </div>

            <!-- Circle Diameter Controls -->
            <div class="mb-6 border-t pt-4">
                <h2 class="text-lg font-semibold mb-3 text-gray-700 transition-colors">Circle Diameter</h2>
                <div class="flex space-x-4 justify-center">
                    <button data-diameter="8" class="diameter-btn w-1/2 p-3 border rounded-lg hover:bg-gray-100 transition duration-150 tool-active" aria-label="8 pixel diameter">8px</button>
                    <button data-diameter="10" class="diameter-btn w-1/2 p-3 border rounded-lg hover:bg-gray-100 transition duration-150" aria-label="10 pixel diameter">10px</button>
                </div>
            </div>
            
            <!-- Grid Toggle -->
            <div class="mb-6 border-t pt-4">
                <label for="grid-toggle" class="flex items-center cursor-pointer">
                    <div class="relative w-10 h-6">
                        <input type="checkbox" id="grid-toggle" checked class="sr-only" aria-label="Show grid dots">
                        <div id="grid-track" class="absolute inset-0 rounded-full transition-colors"></div>
                        <div id="grid-dot" class="absolute w-4 h-4 bg-white rounded-full shadow transition-transform top-1"></div>
                    </div>
                    <div class="ml-3 text-gray-700 font-medium transition-colors">
                        Show Grid Dots
                    </div>
                </label>
            </div>

            <!-- Action Buttons -->
            <div class="border-t pt-4">
                <h2 class="text-lg font-semibold mb-3 text-gray-700 transition-colors">Actions</h2>
                <div id="message-box" class="hidden p-2 mb-2 text-sm bg-green-100 text-green-700 rounded-md" role="alert"></div>
                <div class="space-y-3">
                    <button id="clear-canvas" class="w-full py-3 bg-red-500 text-white font-bold rounded-lg shadow-md hover:bg-red-600 transition duration-150">
                        Clear Canvas
                    </button>
                    <button id="save-png" class="w-full py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150">
                        Save as PNG
                    </button>
                    <button id="save-svg" class="w-full py-3 bg-purple-600 text-white font-bold rounded-lg shadow-md hover:bg-purple-700 transition duration-150">
                        Save as SVG
                    </button>
                </div>
            </div>
        </div>

        <!-- ====================================
             RIGHT AREA: DRAWING CANVAS
             ==================================== -->
        <div class="flex-grow flex justify-center items-start pt-4">
            <div id="canvas-container" class="relative p-0 bg-white shadow-2xl">
                <canvas id="drawingCanvas" width="500" height="500" class="border-2 border-gray-400"></canvas>
                <!-- Resize handle in bottom-right corner -->
                <div id="resize-handle" aria-label="Resize canvas"></div>
                <!-- Line length popup (shown during line drawing) -->
                <div id="line-length-popup" class="absolute hidden bg-gray-900 text-white text-xs px-2 py-1 rounded-md shadow-lg pointer-events-none z-10">
                    0 px
                </div>
            </div>
        </div>
    </div>

    <script>
        // ====================================
        // CONSTANTS
        // ====================================
        const GRID_SIZE = 10; // Snap-to-grid size in pixels
        const MAX_CANVAS_SIZE = 500; // Maximum canvas dimension
        const LINE_SNAP_TOLERANCE = 15; // Eraser detection radius for lines
        
        // ====================================
        // APPLICATION STATE
        // ====================================
        const state = {
            drawings: [], // Array of drawing objects (lines and circles)
            currentTool: 'line', // Active tool: 'line', 'circle', or 'eraser'
            
            // Color and style properties
            bgColor: '#ffffff',
            isBgTransparent: false, 
            lineColor: '#000000',
            glowColor: '#77ffff', 
            glowDistance: 0, // 0-3 (multiplied by 5 for shadow blur)
            
            // Drawing properties
            lineThickness: 4, 
            circleDiameter: 8, 
            
            // Interaction state
            isDrawing: false,
            isResizing: false,
            startPos: {x: 0, y: 0},
            
            // UI state
            showGrid: true, 
            canvasWidth: MAX_CANVAS_SIZE,
            canvasHeight: MAX_CANVAS_SIZE,
        };

        // ====================================
        // DOM ELEMENT REFERENCES
        // ====================================
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const canvasContainer = document.getElementById('canvas-container');
        const resizeHandle = document.getElementById('resize-handle');
        const tools = document.querySelectorAll('.tool-btn');
        const thicknessButtons = document.querySelectorAll('.thickness-btn');
        const diameterButtons = document.querySelectorAll('.diameter-btn');
        
        // Background color controls
        const bgColorWrapper = document.getElementById('bgColorWrapper');
        const bgColorPickerIndicator = document.getElementById('bg-indicator-color-picker');
        const bgIndicator = document.getElementById('bg-indicator');
        const bgIndicatorLabel = document.getElementById('bg-indicator-label');
        const bgColorInput = document.getElementById('bgColor');
        const bgColorHexInput = document.getElementById('bgColorHex');
        const toggleTransparentButton = document.getElementById('toggle-transparent');
        
        // Line/circle color controls
        const drawColorInput = document.getElementById('drawColor');
        const drawColorHexInput = document.getElementById('drawColorHex');
        
        // Glow controls
        const glowColorInput = document.getElementById('glowColor');
        const glowColorHexInput = document.getElementById('glowColorHex');
        const glowDistanceSlider = document.getElementById('glowDistance');

        // UI controls
        const gridToggle = document.getElementById('grid-toggle');
        const gridTrack = document.getElementById('grid-track');
        const gridDot = document.getElementById('grid-dot');
        const msgBox = document.getElementById('message-box');
        const themeToggle = document.getElementById('theme-toggle');
        const sunIcon = document.getElementById('sun-icon');
        const moonIcon = document.getElementById('moon-icon');
        const lineLengthPopup = document.getElementById('line-length-popup');

        // ====================================
        // UTILITY FUNCTIONS
        // ====================================
        
        /**
         * Snaps a coordinate to the nearest grid point
         * @param {number} coord - The coordinate to snap
         * @returns {number} - Snapped coordinate
         */
        function snapToGrid(coord) {
            return Math.round(coord / GRID_SIZE) * GRID_SIZE;
        }

        /**
         * Displays a temporary message to the user
         * @param {string} text - Message text
         * @param {boolean} isError - Whether this is an error message
         */
        function showMessage(text, isError = false) {
            msgBox.textContent = text;
            msgBox.className = `p-2 mb-2 text-sm rounded-md ${isError ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`;
            msgBox.style.display = 'block';
            setTimeout(() => {
                msgBox.style.display = 'none';
            }, 3000);
        }

        /**
         * Shows and updates the line length popup during drawing
         * @param {number} x1 - Start x coordinate
         * @param {number} y1 - Start y coordinate
         * @param {number} x2 - End x coordinate
         * @param {number} y2 - End y coordinate
         * @param {number} cursorX - Cursor x position in container
         * @param {number} cursorY - Cursor y position in container
         */
        function updateLineLengthDisplay(x1, y1, x2, y2, cursorX, cursorY) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.round(Math.sqrt(dx * dx + dy * dy));
            lineLengthPopup.textContent = `${length} px`;
            lineLengthPopup.style.left = `${cursorX}px`;
            lineLengthPopup.style.top = `${cursorY}px`;
            lineLengthPopup.classList.remove('hidden');
            lineLengthPopup.style.opacity = 1;
        }

        /**
         * Hides the line length popup with fade-out effect
         */
        function hideLineLengthDisplay() {
            lineLengthPopup.style.opacity = 0;
            setTimeout(() => {
                if (lineLengthPopup.style.opacity === '0') {
                    lineLengthPopup.classList.add('hidden');
                }
            }, 200);
        }

        /**
         * Updates the eye/eye-off icon based on transparency state
         * @param {boolean} isTransparent - Whether background is transparent
         */
        function refreshTransparencyIcon(isTransparent) {
            const iconButton = document.getElementById('toggle-transparent');
            if (!iconButton) return;
            
            // Clear existing icon
            iconButton.innerHTML = ''; 

            // Create SVG element
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '20');
            svg.setAttribute('height', '20');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('fill', 'none');
            svg.setAttribute('stroke', 'currentColor');
            svg.setAttribute('stroke-width', '2');
            svg.setAttribute('stroke-linecap', 'round');
            svg.setAttribute('stroke-linejoin', 'round');
            svg.style.pointerEvents = 'none';
            
            if (isTransparent) {
                // Eye-Off icon (background is transparent)
                const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path1.setAttribute('d', 'M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24');
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '1');
                line.setAttribute('y1', '1');
                line.setAttribute('x2', '23');
                line.setAttribute('y2', '23');
                svg.appendChild(path1);
                svg.appendChild(line);
            } else {
                // Eye icon (background has color)
                const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path1.setAttribute('d', 'M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z');
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '12');
                circle.setAttribute('cy', '12');
                circle.setAttribute('r', '3');
                svg.appendChild(path1);
                svg.appendChild(circle);
            }
            
            iconButton.appendChild(svg);
        }

        /**
         * Updates the UI to reflect background transparency state
         */
        function updateBackgroundUI() {
            if (state.isBgTransparent) {
                // Show transparency indicators
                bgIndicator.classList.add('transparent');
                bgColorPickerIndicator.classList.add('transparent');
                bgColorWrapper.classList.add('transparent-bg-wrapper');
                bgColorHexInput.disabled = true;
                bgIndicatorLabel.style.display = 'flex';
            } else {
                // Hide transparency indicators
                bgIndicator.classList.remove('transparent');
                bgColorPickerIndicator.classList.remove('transparent');
                bgColorWrapper.classList.remove('transparent-bg-wrapper');
                bgColorHexInput.disabled = false;
                bgColorHexInput.value = state.bgColor;
                bgIndicatorLabel.style.display = 'none';
            }
            
            refreshTransparencyIcon(state.isBgTransparent);
            render();
        }

        // ====================================
        // CANVAS RENDERING FUNCTIONS
        // ====================================

        /**
         * Draws the grid guide dots on the canvas
         * @param {CanvasRenderingContext2D} targetCtx - Context to draw on
         */
        function drawGrid(targetCtx = ctx) {
            if (!state.showGrid) return;
            
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            targetCtx.fillStyle = isDark ? '#6b7280' : '#ccc';
            
            const width = targetCtx.canvas.width;
            const height = targetCtx.canvas.height;

            for (let i = 0; i <= width; i += GRID_SIZE) {
                for (let j = 0; j <= height; j += GRID_SIZE) {
                    targetCtx.beginPath();
                    targetCtx.arc(i, j, 1, 0, 2 * Math.PI); 
                    targetCtx.fill();
                }
            }
        }

        /**
         * Applies glow effect to the context
         * @param {Object} element - Drawing element with glow properties
         * @param {CanvasRenderingContext2D} targetCtx - Context to apply glow to
         */
        function applyGlow(element, targetCtx) {
            if (element.glowDistance > 0) {
                targetCtx.shadowBlur = element.glowDistance * 5; 
                targetCtx.shadowColor = element.glowColor;
                targetCtx.shadowOffsetX = 0;
                targetCtx.shadowOffsetY = 0;
            } else {
                targetCtx.shadowBlur = 0;
                targetCtx.shadowColor = 'transparent';
            }
        }

        /**
         * Resets shadow effects on the context
         * @param {CanvasRenderingContext2D} targetCtx - Context to reset
         */
        function resetGlow(targetCtx) {
            targetCtx.shadowBlur = 0;
            targetCtx.shadowColor = 'transparent';
            targetCtx.shadowOffsetX = 0;
            targetCtx.shadowOffsetY = 0;
        }
        
        /**
         * Draws a line segment on the canvas
         * @param {Object} line - Line object with data and style properties
         * @param {CanvasRenderingContext2D} targetCtx - Context to draw on
         */
        function drawLine(line, targetCtx) {
            const { x1, y1, x2, y2 } = line.data;
            const thickness = line.thickness;
            
            applyGlow(line, targetCtx);

            targetCtx.beginPath();
            targetCtx.moveTo(x1, y1);
            targetCtx.lineTo(x2, y2);
            targetCtx.strokeStyle = line.color;
            targetCtx.lineWidth = thickness;
            targetCtx.lineCap = 'round';
            targetCtx.stroke();
            
            resetGlow(targetCtx);
        }
        
        /**
         * Draws a circle with knockout effect (hollow center)
         * @param {Object} circle - Circle object with data and style properties
         * @param {CanvasRenderingContext2D} targetCtx - Context to draw on
         */
        function drawCircle(circle, targetCtx) {
            const { x, y } = circle.data;
            const thickness = circle.thickness;
            const radius = circle.data.diameter / 2;

            // Draw the colored stroke with glow
            applyGlow(circle, targetCtx);
            
            targetCtx.beginPath();
            targetCtx.arc(x, y, radius, 0, 2 * Math.PI);
            targetCtx.strokeStyle = circle.color;
            targetCtx.lineWidth = thickness;
            targetCtx.stroke();
            
            resetGlow(targetCtx);

            // Draw knockout fill to create hollow center
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            let knockoutFill = state.isBgTransparent 
                ? (isDark ? '#374151' : '#ffffff') 
                : state.bgColor;
            
            targetCtx.beginPath();
            const knockoutRadius = radius - thickness / 2;
            if (knockoutRadius > 0) {
                targetCtx.arc(x, y, knockoutRadius, 0, 2 * Math.PI); 
                targetCtx.fillStyle = knockoutFill; 
                targetCtx.fill();
            }
        }

        /**
         * Main rendering function - draws all elements on the canvas
         * @param {Array} elements - Array of drawing elements to render
         * @param {CanvasRenderingContext2D} targetCtx - Context to render to
         */
        function render(elements = state.drawings, targetCtx = ctx) {
            const width = targetCtx.canvas.width;
            const height = targetCtx.canvas.height;
            
            // Clear and set background
            targetCtx.clearRect(0, 0, width, height);
            
            if (!state.isBgTransparent) {
                targetCtx.fillStyle = state.bgColor;
                targetCtx.fillRect(0, 0, width, height);
            }
            
            // Draw grid (only on main canvas)
            if (targetCtx === ctx) {
                drawGrid(targetCtx);
            }

            // Draw lines first (bottom layer)
            elements.filter(e => e.type === 'line').forEach(line => {
                drawLine(line, targetCtx);
            });
            
            // Draw circles on top
            elements.filter(e => e.type === 'circle').forEach(circle => {
                drawCircle(circle, targetCtx);
            });
        }
        
        // ====================================
        // EXPORT FUNCTIONS
        // ====================================

        /**
         * Generates SVG string from current drawings
         * @returns {string} - Complete SVG markup
         */
        function generateSVGString() {
            const width = state.canvasWidth;
            const height = state.canvasHeight;
            let svgContent = '';
            
            // Add background
            if (!state.isBgTransparent) {
                svgContent += `<rect x="0" y="0" width="${width}" height="${height}" fill="${state.bgColor}" />\n`;
            } else {
                svgContent += `<!-- Transparent background -->\n`;
            }

            // Add lines
            svgContent += '<g class="lines">\n';
            state.drawings.filter(e => e.type === 'line').forEach(line => {
                const { x1, y1, x2, y2 } = line.data;
                svgContent += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${line.color}" stroke-width="${line.thickness}" stroke-linecap="round" />\n`;
            });
            svgContent += '</g>\n';
            
            // Add circles with knockout effect
            svgContent += '<g class="circles">\n';
            state.drawings.filter(e => e.type === 'circle').forEach((circle) => {
                const { x, y } = circle.data;
                const thickness = circle.thickness;
                const radius = circle.data.diameter / 2;
                
                const isDark = document.body.getAttribute('data-theme') === 'dark';
                let fillColor = state.isBgTransparent 
                    ? (isDark ? '#374151' : '#ffffff') 
                    : state.bgColor;
                
                // Knockout fill circle
                const knockoutRadius = radius - thickness / 2;
                if (knockoutRadius > 0) {
                    svgContent += `<circle cx="${x}" cy="${y}" r="${knockoutRadius}" fill="${fillColor}" />\n`; 
                }

                // Stroke circle
                svgContent += `<circle cx="${x}" cy="${y}" r="${radius}" stroke="${circle.color}" stroke-width="${thickness}" fill="none" />\n`;
            });
            svgContent += '</g>\n';

            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">\n${svgContent}</svg>`;
        }
        
        /**
         * Exports the canvas as PNG or SVG
         * @param {string} format - Export format ('png' or 'svg')
         */
        async function exportImage(format) {
            if (state.drawings.length === 0) {
                showMessage('The drawing area is empty. Nothing to save.', true);
                return;
            }

            const downloadLink = document.createElement('a');
            downloadLink.download = `art-techo-drawing.${format}`;

            if (format === 'svg') {
                const svgString = generateSVGString();
                const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                downloadLink.href = URL.createObjectURL(svgBlob);
                downloadLink.click();
                showMessage('Image saved as SVG (Vector File).');
            } else if (format === 'png') {
                // Render to temporary canvas without grid
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = state.canvasWidth;
                tempCanvas.height = state.canvasHeight;
                const tempCtx = tempCanvas.getContext('2d');
                
                const originalShowGrid = state.showGrid;
                state.showGrid = false; 
                render(state.drawings, tempCtx); 
                state.showGrid = originalShowGrid;

                downloadLink.href = tempCanvas.toDataURL('image/png');
                downloadLink.click();
                showMessage('Image saved as PNG (Raster Image).');
                render();
            }
        }

        // ====================================
        // EVENT HANDLERS - THEME TOGGLE
        // ====================================
        
        /**
         * Toggles between light and dark theme
         */
        function toggleTheme() {
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            if (isDark) {
                document.body.setAttribute('data-theme', 'light');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            } else {
                document.body.setAttribute('data-theme', 'dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            }
            render(); 
        }
        themeToggle.addEventListener('click', toggleTheme);
        
        // ====================================
        // EVENT HANDLERS - TOOL SELECTION
        // ====================================
        
        // Tool button selection
        tools.forEach(btn => {
            btn.addEventListener('click', () => {
                tools.forEach(b => b.classList.remove('tool-active'));
                btn.classList.add('tool-active');
                state.currentTool = btn.dataset.tool;
            });
        });
        
        // Line thickness selection
        thicknessButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                thicknessButtons.forEach(b => b.classList.remove('tool-active'));
                btn.classList.add('tool-active');
                state.lineThickness = parseInt(btn.dataset.thickness);
            });
        });

        // Circle diameter selection
        diameterButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                diameterButtons.forEach(b => b.classList.remove('tool-active'));
                btn.classList.add('tool-active');
                state.circleDiameter = parseInt(btn.dataset.diameter);
            });
        });

        // ====================================
        // EVENT HANDLERS - COLOR CONTROLS
        // ====================================

        // Background color picker
        bgColorInput.addEventListener('input', (e) => { 
            state.bgColor = e.target.value.toLowerCase(); 
            state.isBgTransparent = false; 
            bgColorHexInput.value = state.bgColor;
            updateBackgroundUI();
        });
        
        // Background hex input
        bgColorHexInput.addEventListener('input', (e) => {
            const value = e.target.value.toLowerCase();
            if (value.match(/^#([0-9a-f]{3}){1,2}$/i)) { 
                state.bgColor = value; 
                state.isBgTransparent = false;
                bgColorInput.value = value;
                updateBackgroundUI();
            }
        });
        
        // Transparency toggle button
        toggleTransparentButton.addEventListener('click', (e) => {
            e.preventDefault();
            state.isBgTransparent = !state.isBgTransparent;
            updateBackgroundUI();
        });

        // Line/circle color picker
        drawColorInput.addEventListener('input', (e) => { 
            state.lineColor = e.target.value.toLowerCase(); 
            drawColorHexInput.value = state.lineColor; 
        });
        
        // Line/circle hex input
        drawColorHexInput.addEventListener('input', (e) => {
            const value = e.target.value.toLowerCase();
            if (value.match(/^#([0-9a-f]{3}){1,2}$/i)) { 
                state.lineColor = value; 
                drawColorInput.value = value; 
            }
        });

        // Glow color picker
        glowColorInput.addEventListener('input', (e) => { 
            state.glowColor = e.target.value.toLowerCase(); 
            glowColorHexInput.value = state.glowColor; 
            render();
        });
        
        // Glow hex input
        glowColorHexInput.addEventListener('input', (e) => {
            const value = e.target.value.toLowerCase();
            if (value.match(/^#([0-9a-f]{3}){1,2}$/i)) { 
                state.glowColor = value; 
                glowColorInput.value = value; 
                render();
            }
        });
        
        // Glow distance slider
        glowDistanceSlider.addEventListener('input', (e) => {
            state.glowDistance = parseInt(e.target.value);
            render();
        });
        
        // ====================================
        // EVENT HANDLERS - GRID TOGGLE
        // ====================================
        
        /**
         * Updates the visual state of the grid toggle switch
         * @param {boolean} isChecked - Whether grid is enabled
         */
        function updateGridToggleVisual(isChecked) {
            if (gridTrack && gridDot) {
                if (isChecked) {
                    gridTrack.classList.remove('bg-gray-600');
                    gridTrack.classList.add('bg-blue-500');
                    gridDot.classList.remove('left-1');
                    gridDot.classList.add('translate-x-4', 'left-1');
                } else {
                    gridTrack.classList.add('bg-gray-600');
                    gridTrack.classList.remove('bg-blue-500');
                    gridDot.classList.remove('translate-x-4');
                    gridDot.classList.add('left-1');
                }
            }
        }
        
        gridToggle.addEventListener('change', (e) => { 
            state.showGrid = e.target.checked; 
            updateGridToggleVisual(state.showGrid); 
            render(); 
        });

        // ====================================
        // EVENT HANDLERS - CANVAS RESIZING
        // ====================================
        
        /**
         * Updates canvas dimensions with grid snapping
         * @param {number} newWidth - New canvas width
         * @param {number} newHeight - New canvas height
         */
        function updateCanvasSize(newWidth, newHeight) {
            // Snap to grid and constrain to limits
            let snappedWidth = Math.min(MAX_CANVAS_SIZE, snapToGrid(Math.max(GRID_SIZE, newWidth)));
            let snappedHeight = Math.min(MAX_CANVAS_SIZE, snapToGrid(Math.max(GRID_SIZE, newHeight)));

            canvas.width = snappedWidth;
            canvas.height = snappedHeight;
            canvasContainer.style.width = `${snappedWidth}px`;
            canvasContainer.style.height = `${snappedHeight}px`;

            state.canvasWidth = snappedWidth;
            state.canvasHeight = snappedHeight;

            render();
        }

        // Resize handle mouse down
        resizeHandle.addEventListener('mousedown', (e) => {
            state.isResizing = true;
            canvas.style.pointerEvents = 'none'; 
            document.body.style.cursor = 'nwse-resize';
            e.stopPropagation();
        });
        
        // Mouse move for resizing
        document.addEventListener('mousemove', (e) => {
            if (!state.isResizing) return;
            const rect = canvas.getBoundingClientRect();
            let newWidth = Math.min(MAX_CANVAS_SIZE, Math.max(50, e.clientX - rect.left));
            let newHeight = Math.min(MAX_CANVAS_SIZE, Math.max(50, e.clientY - rect.top));
            updateCanvasSize(newWidth, newHeight);
        });

        // Mouse up to end resizing
        document.addEventListener('mouseup', () => {
            if (state.isResizing) {
                state.isResizing = false;
                canvas.style.pointerEvents = 'auto'; 
                document.body.style.cursor = 'default';
                updateCanvasSize(state.canvasWidth, state.canvasHeight);
            }
        });

        // ====================================
        // EVENT HANDLERS - DRAWING
        // ====================================
        
        /**
         * Converts client coordinates to canvas coordinates
         * @param {number} clientX - Client X position
         * @param {number} clientY - Client Y position
         * @returns {Object} - Canvas coordinates (snapped and raw)
         */
        function getCanvasCoords(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: snapToGrid(clientX - rect.left),
                y: snapToGrid(clientY - rect.top),
                rawX: clientX - rect.left, 
                rawY: clientY - rect.top
            };
        }
        
        /**
         * Extracts client coordinates from mouse or touch event
         * @param {Event} event - Mouse or touch event
         * @returns {Object} - Client coordinates
         */
        function getEventClientCoords(event) {
            if (event.clientX !== undefined) {
                return { clientX: event.clientX, clientY: event.clientY };
            } else if (event.touches && event.touches.length > 0) {
                return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                return { clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY };
            }
            return { clientX: 0, clientY: 0 };
        }

        /**
         * Handles the start of a drawing action
         * @param {Event} event - Mouse or touch event
         */
        function handlePointerStart(event) {
            if (state.isResizing) return;
            event.preventDefault(); 
            
            const { clientX, clientY } = getEventClientCoords(event);
            const { x, y } = getCanvasCoords(clientX, clientY);
            
            state.startPos = {x, y};
            state.isDrawing = true;

            // Capture current drawing properties
            const drawingProps = {
                color: state.lineColor,
                thickness: state.lineThickness,
                glowColor: state.glowColor,
                glowDistance: state.glowDistance,
            };

            if (state.currentTool === 'circle') {
                // Place circle immediately
                state.drawings.push({
                    type: 'circle',
                    data: {x, y, diameter: state.circleDiameter}, 
                    ...drawingProps
                });
                render();
                state.isDrawing = false; 
            } else if (state.currentTool === 'eraser') {
                // Check if clicking on a circle
                const circleIndex = state.drawings.findIndex(e => 
                    e.type === 'circle' && e.data.x === x && e.data.y === y
                );
                if (circleIndex !== -1) { 
                    state.drawings.splice(circleIndex, 1); 
                    render(); 
                    showMessage('Circle deleted.', true); 
                }
            } else if (state.currentTool === 'line') {
                // Start new line
                state.drawings.push({
                    type: 'line',
                    data: {x1: x, y1: y, x2: x, y2: y}, 
                    ...drawingProps
                });
            }
        }
        
        /**
         * Handles drawing movement (line preview)
         * @param {Event} event - Mouse or touch event
         */
        function handlePointerMove(event) {
            if (!state.isDrawing) return;
            event.preventDefault();
            
            const { clientX, clientY } = getEventClientCoords(event);
            const { x, y, rawX, rawY } = getCanvasCoords(clientX, clientY);

            if (state.currentTool === 'line') {
                const currentLine = state.drawings[state.drawings.length - 1];
                if (currentLine && currentLine.type === 'line') { 
                    currentLine.data.x2 = x; 
                    currentLine.data.y2 = y; 
                    render(); 
                    updateLineLengthDisplay(currentLine.data.x1, currentLine.data.y1, x, y, rawX, rawY);
                }
            }
        }
        
        /**
         * Handles end of drawing action
         * @param {Event} event - Mouse or touch event
         */
        function handlePointerEnd(event) {
            if (!state.isDrawing) return;
            state.isDrawing = false;
            
            hideLineLengthDisplay();
            
            const { clientX, clientY } = getEventClientCoords(event);
            const endRect = canvas.getBoundingClientRect();
            const endX = snapToGrid(clientX - endRect.left);
            const endY = snapToGrid(clientY - endRect.top);

            if (state.currentTool === 'line') {
                const currentLine = state.drawings[state.drawings.length - 1];
                if (currentLine && currentLine.type === 'line') {
                    // Remove line if start and end are the same (just a click)
                    if (state.startPos.x === endX && state.startPos.y === endY) { 
                        state.drawings.pop(); 
                    } else {
                        currentLine.data.x1 = state.startPos.x;
                        currentLine.data.y1 = state.startPos.y;
                        currentLine.data.x2 = endX;
                        currentLine.data.y2 = endY;
                    }
                }
            } else if (state.currentTool === 'eraser') {
                // Check for line deletion
                const eraseX = endX;
                const eraseY = endY;
                let deleted = false;
                
                for (let i = state.drawings.length - 1; i >= 0; i--) {
                    const el = state.drawings[i];
                    if (el.type !== 'line') continue;
                    
                    const { x1, y1, x2, y2 } = el.data;
                    
                    // Calculate distance from point to line segment
                    const A = eraseX - x1;
                    const B = eraseY - y1;
                    const C = x2 - x1;
                    const D = y2 - y1;
                    const dot = A * C + B * D;
                    const len_sq = C * C + D * D;
                    let param = len_sq !== 0 ? dot / len_sq : -1;

                    let closestX = (param < 0) ? x1 : (param > 1) ? x2 : x1 + param * C;
                    let closestY = (param < 0) ? y1 : (param > 1) ? y2 : y1 + param * D;

                    const dist = Math.sqrt(Math.pow(eraseX - closestX, 2) + Math.pow(eraseY - closestY, 2));
                    
                    if (dist < LINE_SNAP_TOLERANCE) {
                        state.drawings.splice(i, 1);
                        deleted = true;
                        break;
                    }
                }
                if (deleted) { 
                    showMessage('Line segment deleted.', true); 
                }
            }
            render();
        }

        // Register drawing event listeners
        canvas.addEventListener('mousedown', handlePointerStart);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseup', handlePointerEnd);
        canvas.addEventListener('touchstart', handlePointerStart);
        canvas.addEventListener('touchmove', handlePointerMove);
        canvas.addEventListener('touchend', handlePointerEnd);
        
        // ====================================
        // EVENT HANDLERS - ACTION BUTTONS
        // ====================================
        
        document.getElementById('save-png').addEventListener('click', () => exportImage('png'));
        document.getElementById('save-svg').addEventListener('click', () => exportImage('svg'));
        document.getElementById('clear-canvas').addEventListener('click', () => { 
            state.drawings = [];
            render(); 
            showMessage('Canvas cleared successfully!', true); 
        });

        // ====================================
        // INITIALIZATION
        // ====================================
        
        /**
         * Initializes the application on page load
         */
        function initializeApp() {
            // Set initial canvas size
            updateCanvasSize(state.canvasWidth, state.canvasHeight);
            
            // Set initial active states
            document.querySelector(`.thickness-btn[data-thickness="${state.lineThickness}"]`)?.classList.add('tool-active');
            document.querySelector(`.diameter-btn[data-diameter="${state.circleDiameter}"]`)?.classList.add('tool-active');
            
            // Initialize grid toggle
            gridToggle.checked = state.showGrid;
            updateGridToggleVisual(state.showGrid); 
            
            // Initialize transparency UI
            refreshTransparencyIcon(state.isBgTransparent);
            updateBackgroundUI();
            bgIndicatorLabel.style.display = 'none';

            // Initial render
            render();
        }

        window.onload = initializeApp;
    </script>
</body>
</html>
